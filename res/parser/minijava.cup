import java_cup.runtime.*;

import java.io.*;
import java.util.Stack;

import se.cortado.Scanner;
import se.cortado.syntaxtree.*;
import se.cortado.sym;


/* Preliminaries to set up and use the scanner.  */

action code {:
	public ClassDeclList mClassDeclStack = new ClassDeclList();
	public ExpList mExpStack = new ExpList();
	public FormalList mFormalStack = new FormalList();
	public StatementList mStatementStack = new StatementList();
	public VarDeclList mClassVarDeclStack = new VarDeclList();
	public VarDeclList mVarDeclStack = new VarDeclList();
	public MethodDeclList mMethodDeclStack = new MethodDeclList();
:};

parser code {:

	private Scanner scanner;
	private File file;
	
	Symbol current_symbol;
	
	Stack<FormalList> formalLists = new Stack<FormalList>();

	public void syntax_error(Symbol cur_token){
		System.out.println("syntax_error:" + cur_token);
	}
	
	public int intFromValue(String v) {
		return Integer.parseInt(v);
	}
:};

scan with {: 
			current_symbol = getScanner().next_token();
			//System.out.println("" + current_symbol);
			return current_symbol;
			:};

/* ======== Terminals (tokens RESULTed by the scanner) ======== */

/* MISC */
terminal					PUBLIC, STATIC, VOID, CLASS, COMMA, DOT, NEW, RETURN;

/* Statements */
terminal If 				IF;
terminal While 				WHILE;
terminal Print 				SYSOUT;
terminal 					ELSE;

/* Expressions */
terminal 					LENGTH;
terminal 					TRUE;
terminal  					FALSE;
terminal 					THIS;
terminal 					BANG;
terminal 					INTEGER;

/* Datatypes */
terminal String				IDENTIFIER;
terminal 					INT, INT_ARRAY, BOOLEAN, STRING_ARRAY;

/* Operators */
terminal Plus 				PLUS;
terminal Minus 				MINUS;
terminal Times 				MULTIPLY;
terminal And				AND;
terminal LessThan 			LESS;
terminal		 			ASSIGN;

terminal 					LPAREN, RPAREN, LBRACKET, RBRACKET, LCURLY, RCURLY;

terminal 					SEMI;

/* Non terminals */
non terminal Program 		program;
non terminal MainClass 		main_class;
non terminal MethodDecl 	main_method;
non terminal ClassDecl		class_decl;
non terminal VarDecl		var_decl;
non terminal MethodDecl		method_decl;

non terminal Statement		stmt;
non terminal Exp 			expr;
non terminal Formal			formal;
non terminal Type			type;
non terminal Exp			returnExp;

non terminal ExpList 		expr_list;
non terminal ClassDeclList 	class_decls;
non terminal MethodDeclList	method_decls;
non terminal FormalList 	formal_list;
non terminal VarDeclList 	var_decls;
non terminal StatementList 	stmt_list;
non terminal 				empty;
non terminal var_declls, stmt_listt;

/* Precedences */
precedence left BANG;
precedence left PLUS, MINUS;
precedence left MULTIPLY;
precedence left AND, LESS, DOT;

/* State to start with */
start with program;


/* ======== The grammar ======== */

program ::= main_class:mc class_decls:cdl
				{: RESULT = new Program(mc, cdl); :}
				;

main_class ::= CLASS IDENTIFIER:id LCURLY main_method:md RCURLY 
				{: RESULT = new MainClass(new Identifier(id), md); :}
				;

main_method ::= PUBLIC STATIC VOID IDENTIFIER:id1 LPAREN STRING_ARRAY IDENTIFIER:id2 RPAREN LCURLY var_decls:vd stmt_list:sl RCURLY
				{: 	FormalList fl = new FormalList();
					fl.addElement(new Formal(new StringArrayType(), new Identifier(id2)));
					VarDeclList curVarDeclStack = mVarDeclStack;
					mVarDeclStack = new VarDeclList();
					StatementList curStatementStack = mStatementStack;
					mStatementStack = new StatementList();				
	/// TODO: new void return type?
	
					RESULT = new MethodDecl(new VoidType(), new Identifier(id1), fl, curVarDeclStack, curStatementStack, new IdentifierExp("voidType")); :}
				;

var_decls 		::= var_declls | empty;
var_declls 		::= var_declls var_decl | var_decl;
var_decl 		::= type:t IDENTIFIER:id SEMI
						{:	mVarDeclStack.addElement(new VarDecl(t, new Identifier(id))); :}
					;

stmt_list 		::= stmt_listt | empty;
stmt_listt		::= stmt_listt stmt | stmt;
stmt 			::=	LCURLY stmt_list RCURLY 
				| IF LPAREN expr:e RPAREN stmt:s1 ELSE stmt:s2
					{: mStatementStack.addElement(new If(e, s1, s2)); :}
				| WHILE LPAREN expr:e RPAREN stmt:s
					{: mStatementStack.addElement(new While(e, s)); :}
				| SYSOUT LPAREN expr:e RPAREN SEMI
					{: mStatementStack.addElement(new Print(e)); :}
				| IDENTIFIER:id ASSIGN expr:e SEMI
					{: mStatementStack.addElement(new Assign(new Identifier(id), e)); :}
				| IDENTIFIER:id LBRACKET expr:e1 RBRACKET ASSIGN expr:e2 SEMI
					{: mStatementStack.addElement(new ArrayAssign(new Identifier(id), e1, e2)); :}
				;

method_decls 	::= method_decls method_decl | method_decl;
method_decl 	::= PUBLIC type:t IDENTIFIER:id LPAREN formal_list RPAREN LCURLY var_decls stmt_list returnExp:e SEMI RCURLY
					{:	
						FormalList curFormalStack = mFormalStack;
						VarDeclList curVarDeclStack = mVarDeclStack;
						StatementList curStatementStack = mStatementStack;
						
						mFormalStack = new FormalList();
						mVarDeclStack = new VarDeclList();
						mStatementStack = new StatementList();
						
						mMethodDeclStack.addElement(new MethodDecl(t, new Identifier(id), curFormalStack, curVarDeclStack, curStatementStack, e)); :}
					;

returnExp		::= RETURN expr:e
					{: RESULT = e; :} 
					| empty;

class_decl 		::= CLASS IDENTIFIER:id LCURLY var_decls method_decls RCURLY
	{:	
		VarDeclList curVarDeclStack = mClassVarDeclStack;
		MethodDeclList curMethodDeclStack = mMethodDeclStack;
		
		mClassVarDeclStack = new VarDeclList();
		mMethodDeclStack = new MethodDeclList();
		

		
		RESULT = new ClassDeclSimple(new Identifier(id), curVarDeclStack, curMethodDeclStack);
	:}
;

class_decls 	::= class_decl:cd
						{: ClassDeclList cdl = new ClassDeclList();
							cdl.addElement(cd);
							RESULT = cdl;
						:}
					| class_decls:cdl class_decl:cd
						{:
							cdl.addElement(cd);
							RESULT = cdl;
						:}
					;

/* TODO */
type ::= 		INT		 		{: RESULT = new IntegerType(); :} 
				| INT_ARRAY 	{: RESULT = new IntArrayType(); :}
				| BOOLEAN 		{: RESULT = new BooleanType(); :}
				| IDENTIFIER:id	{: RESULT = new IdentifierType(id); :}
				;
	
formal_list 	::= formal_list:fl COMMA formal
				| formal:f {: mFormalStack.addElement(f); :}
				;

formal 			::= type:t IDENTIFIER:id
					{: RESULT = new Formal(t, new Identifier(id)); :}
				;

expr_list ::= 	expr_list:el COMMA expr:e1
					{: mExpStack.addElement(e1); :}
				| expr:e 
					{: mExpStack.addElement(e); :}
				;

expr ::=	expr:e1 PLUS expr:e2 
				{: RESULT = new Plus(e1, e2); :}
			| expr:e1 MINUS expr:e2
				{: RESULT = new Minus(e1, e2); :}
			| expr:e1 MULTIPLY expr:e2
				{: RESULT = new Times(e1, e2); :}
			| expr:e1 AND expr:e2
				{: RESULT = new And(e1, e2); :}
			| expr:e1 LESS expr:e2
				{: RESULT = new LessThan(e1, e2); :}
			| expr:e1 LBRACKET expr:e2 RBRACKET
				{: RESULT = new ArrayLookup(e1, e2); :}
			| expr:e1 DOT LENGTH
				{: RESULT = new ArrayLength(e1); :}
			| expr:e1 DOT IDENTIFIER:id LPAREN expr_list RPAREN
				{: ExpList el = mExpStack;
					mExpStack = new ExpList();
					RESULT = new Call(e1, new Identifier(id), el); :}
			| INTEGER:i
				{: RESULT = new IntegerLiteral(1); :}
			| TRUE
				{: RESULT = new True(); :}
			| FALSE
				{: RESULT = new False(); :}
			| IDENTIFIER:id
				{: RESULT = new IdentifierExp("hej"); :}
			| THIS
				{: RESULT = new This(); :}
			| NEW INT LBRACKET expr:e1 RBRACKET
				{: RESULT = new NewArray(e1); :}
			| NEW IDENTIFIER:id LPAREN RPAREN
				{: RESULT = new NewObject(new Identifier(id)); :}
			| BANG expr:e1
				{: RESULT = new Not((Exp) e1); :}
			| LPAREN expr RPAREN
			;

new_array ::=	NEW INT LBRACKET expr:e1 RBRACKET
				{: RESULT = new NewArray(e1); :}
				;

empty ::= ;
