import java_cup.runtime.*;

import java.io.*;
import java.util.Stack;

import se.cortado.Scanner;
import se.cortado.syntaxtree.*;
import se.cortado.sym;


/* Preliminaries to set up and use the scanner.  */

parser code {:
	public ClassDeclList classStack = new ClassDeclList();
	public ExpList expStack = new ExpList();
	public FormalList formalStack = new FormalList();
	public StatementList statementStack = new StatementList();
	public VarDeclList varStack = new VarDeclList();

	private Scanner scanner;
	private File file;
	
	Stack<FormalList> formalLists = new Stack<FormalList>();
	
/* 	public parser(File file) {
		this();
		this.file = file;
		try {
			scanner = new Scanner(new FileReader(file));
		}
		catch (IOException exception) {
			throw new Error("Unable to open file \"" + file + "\"");
		}
	} */

	public void syntax_error(Symbol cur_token){
		System.out.println("syntax_error:" + cur_token);

	}

:};

/* ======== Terminals (tokens RESULTed by the scanner) ======== */

/* MISC */
terminal		PUBLIC, STATIC, VOID, CLASS, COMMA, DOT, RESULT, NEW, RETURN;

/* Statements */
terminal		IF, ELSE, WHILE, SYSOUT;

/* Expressions */
terminal 		LENGTH, TRUE, FALSE, THIS, BANG;

/* Datatypes */
terminal Identifier IDENTIFIER;
terminal 		INT, INT_ARRAY, BOOLEAN, STRING_ARRAY;

/* Operators */
terminal     	PLUS, MINUS, MULTIPLY, LPAREN, RPAREN, LBRACKET, RBRACKET, LCURLY, RCURLY, AND, LESS, ASSIGN;
terminal IntegerLiteral	INTEGER;

terminal SEMI;
/* Non terminals */
non terminal Program program;
non terminal Exp expr;
non terminal MainClass main_class;
non terminal ClassDeclList class_decls;
non terminal MethodDecl main_method;
non terminal FormalList formal_list;
non terminal VarDeclList var_decls;
non terminal StatementList stmt_list;

non terminal expr_list, class_decl, var_decl, method_decl, method_decls, stmt, formal;
non terminal type;

/* Precedences */
precedence left BANG;
precedence left PLUS, MINUS;
precedence left MULTIPLY;
precedence left AND, LESS, DOT;

/* State to start with */
start with program;

/* The grammar */

program ::= main_class:mc class_decls:cd
			{: RESULT = new Program(mc, cd); :};

main_class ::= CLASS IDENTIFIER:id LCURLY main_method:md RCURLY 
				{: RESULT = new MainClass(new Identifier(id.toString()), md); :}
				;

main_method ::= PUBLIC STATIC VOID IDENTIFIER:id1 LPAREN STRING_ARRAY IDENTIFIER:id2 RPAREN LCURLY 
var_decls:vd stmt_list:sl RCURLY
				{: 	FormalList fl = new FormalList();
					fl.addElement(new Formal(new StringArrayType(), new Identifier(id2.toString())));
					RESULT = new MethodDecl(new VoidType(), new Identifier(id1.toString()), fl, vd, sl, new IdentifierExp("hej")); :}
				;

/*
var_decls ::= var_decls var_decl | var_decl;
var_decl ::= type IDENTIFIER SEMI;

method_decls ::= method_decls method_decl | method_decl;
method_decl ::= PUBLIC type IDENTIFIER LPAREN formal_list RPAREN LCURLY var_decls stmt_list RESULT expr SEMI RCURLY;

class_decls ::= class_decls class_decl | class_decl;
class_decl ::= CLASS IDENTIFIER LCURLY var_decls method_decls RCURLY;

type ::= INT | INT_ARRAY | BOOLEAN | IDENTIFIER;

formal_list ::= formal_list:fl COMMA formal
				| formal
				;

formal ::= type:t IDENTIFIER:id
			{: RESULT = new Formal(t, id); :}
			;

stmt_list ::= stmt_list stmt | stmt;
stmt ::=	LCURLY stmt_list RCURLY 
			| IF LPAREN expr RPAREN stmt ELSE stmt
			| WHILE LPAREN expr RPAREN stmt
			| SYSOUT LPAREN expr RPAREN SEMI
			| IDENTIFIER ASSIGN expr SEMI
			| IDENTIFIER LBRACKET expr RBRACKET ASSIGN expr SEMI
			;

expr_list ::= 	expr_list:el COMMA expr:e1
				| expr
				;

expr ::=	expr:e1 PLUS expr:e2
			{: RESULT = new Plus(e1, e2); :}
			| expr:e1 MINUS expr:e2
			{: RESULT = new Minus(e1, e2); :}
			| expr:e1 MULTIPLY expr:e2
			{: RESULT = new Times(e1, e2); :}
			| expr:e1 AND expr:e2
			{: RESULT = new And(e1, e2); :}
			| expr:e1 LESS expr:e2
			{: RESULT = new LessThan(e1, e2); :}
			| expr:e1 LBRACKET expr:e2 RBRACKET
			{: RESULT = new ArrayLookup(e1, e2); :}
			| expr:e1 DOT LENGTH
			{: RESULT = new ArrayLength(e1); :}
			| expr:e1 DOT IDENTIFIER:id LPAREN expr_list:el RPAREN
			{: RESULT = new Call(e1, id, el); :}
			| INTEGER:i
			{: RESULT = new IntegerLiteral(i.intValue()); :}
			| TRUE
			{: RESULT = new True(); :}
			| FALSE
			{: RESULT = new False(); :}
			| IDENTIFIER:id
			{: RESULT = new Identifier(id); :}
			| THIS
			{: RESULT = new This(); :}
			| NEW INT LBRACKET expr:e1 RBRACKET
			{: RESULT = new NewArray(e1); :}
			| NEW IDENTIFIER:id LPAREN RPAREN
			{: RESULT = new NewObject(id); :}
			| BANG expr:e1
			{: RESULT = new Not((Exp) e1); :}
			| LPAREN expr RPAREN
			;

new_array ::=	NEW INT LBRACKET expr:e1 RBRACKET
				{: RESULT = new NewArray(e1); :}
				;


*/
